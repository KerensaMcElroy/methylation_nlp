#!/usr/bin/env python

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

import sys
import time
import numpy as np
import pandas as pd
import math
import os
import logging
import gzip
from Bio import SeqIO

global logger
log = logging.getLogger(__name__)

def fasta_slider(seq_record, size, step):
    """generates sliding windows over nucleotide sequence"""
    i = 0
    while (i < len(seq_record.seq)) :
        f_out = (str(seq_record.seq[i:i+size]) + "\n")
        i += step
        print(f_out)
    
def main(args):
    """Main logic of program."""

    df = pd.read_csv('test/data/filtered_meth_HE%s_chrm%s.dat'%(args.i_HE,args.i_chrm), sep="\s+")
    print("df.shape:", df.shape)

    n_names = [col for col in df.columns if col.startswith('N')]
    print("n_names:", n_names)
    print("len(n_names):", len(n_names))

    x_names = [col for col in df.columns if col.startswith('X')]
    print("x_names:", x_names)
    print("len(x_names):", len(x_names))
##================================================================================================

    n_pos = df.shape[0]
    n_ani = len(n_names)

    a = np.zeros((n_pos, n_ani))
    for i in range(n_ani):
        a[:,i] = df[x_names[i]].values/df[n_names[i]].values

    ## convert NaN to 0
    a = np.nan_to_num(a)
    print("a.shape:", a.shape)

##================================================================================================
    pos = df["Pos"]
    site_end = int(pos.max())
    print("site_end:", site_end)


## sliding windows for single animal
    ia = args.ia_min
    print("ia:", ia)
    ia_dict={}
    for j, n in enumerate(n_names):
        ia_dict[n]=j
    ia=ia_dict[ia]
    print(ia)
    start_time = time.time()


#impute zeros to empty sites
    y = np.zeros(site_end) # +1 because from 0 to df[:,0].max()
    for i,j in enumerate(pos):
        print(i,j,ia)
        print(a[i,ia])
        y[int(j)-1] = a[i,ia]
    print(y)
    print(len(y))
    print(ia)
# find where the zeros end
    site_start = int(pos.min())

# calculate window_mean
    n_windows = math.ceil((len(y[site_start:]) - args.in_window)/args.in_slide) + 1
    window_mean = np.zeros(n_windows)
    window_seq = np.empty(n_windows, dtype='S200') #max length window possible is 200
    window_beg = np.zeros(n_windows)
    window_end = np.zeros(n_windows)
    i = 0 #initiate indexing for window_mean
    p = site_start-1 #because python uses 0 indexing
    record_dict = SeqIO.index(args.in_genome,'fasta')
    record = record_dict[args.i_chrm]
    print(record.seq[1:100])
    print(record.seq[0:10])
    print(record.seq[1:10])
    print(record.seq[4386:4436])
    while i < n_windows:
        w_mean = y[p:p+args.in_window].mean()
        print(y[p:p+args.in_window])
        window_mean[i]=w_mean
        window_beg[i]=p
        window_end[i]=window_beg[i]+args.in_window
        window_seq[i]=str(record.seq[int(window_beg[i]):int(window_end[i])])
        print(window_seq[i]) 
        p += args.in_slide
        i+=1 

    print("finished -- ia: {}, time: {:.2f}".format(ia, time.time() - start_time))
    ta=np.array(list(zip(window_beg+1,window_end+1,window_mean,window_seq)), 'd,d,f,U200')
    print(ta)
    np.savetxt("window_mean_HE%s_chrm%s_ia%s_win%s_step%s.txt"%(args.i_HE, args.i_chrm, ia, args.in_window, args.in_slide),ta , fmt="%d %d %.3f %s")

def fasta_slider(seq_record, size, step):
    """generates sliding windows over nucleotide sequence"""
    i = 0
    while (i < len(seq_record.seq)) :
        f_out = (str(seq_record.seq[i:i+size]) + "\n")
        i += step
        print(f_out)

if __name__ == "__main__":

    import argparse

# setup logging
    logging.basicConfig(filename='./window.log', level=logging.INFO,
                        format='%(asctime)s %(messages)s')

    #parse command line arguments
    parser = argparse.ArgumentParser(description='Generates tab-delimited tidy\
        data for sliding windows over methylation input files generated by xx.')
                                     
    #positional arguments
    parser.add_argument('in_genome', help='Input fasta genome file')
    parser.add_argument('in_window', help='Sliding window size', type=int)
    parser.add_argument('in_slide', help='Sliding window step', type=int)
    parser.add_argument("i_HE", help="Heat stress stage, one of [1,2,3]")
    parser.add_argument("i_chrm", help="Chromosome id, from 1 to 29")
    parser.add_argument("ia_min", help="Animal id, one of [2,5,8,11,14,17,20,23,26,29,32,35,41,44]", type=str)
#    parser.add_argument('in_meth', help='Input methylation file')

    args = parser.parse_args()

    #run program
    main(args)
